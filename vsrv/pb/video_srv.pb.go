// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: video_srv.proto

package vsrvpb

import (
	context "context"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	golang_proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type Video struct {
	VideoId   string `protobuf:"bytes,1,opt,name=video_id,json=videoId,proto3" json:"video_id,omitempty"`
	Title     string `protobuf:"bytes,2,opt,name=title,proto3" json:"title,omitempty"`
	Summary   string `protobuf:"bytes,3,opt,name=summary,proto3" json:"summary,omitempty"`
	CreatedAt int64  `protobuf:"varint,4,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	Poster    string `protobuf:"bytes,5,opt,name=poster,proto3" json:"poster,omitempty"`
	Url       string `protobuf:"bytes,6,opt,name=url,proto3" json:"url,omitempty"`
}

func (m *Video) Reset()         { *m = Video{} }
func (m *Video) String() string { return proto.CompactTextString(m) }
func (*Video) ProtoMessage()    {}
func (*Video) Descriptor() ([]byte, []int) {
	return fileDescriptor_e52170e594c21869, []int{0}
}
func (m *Video) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Video) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Video.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Video) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Video.Merge(m, src)
}
func (m *Video) XXX_Size() int {
	return m.Size()
}
func (m *Video) XXX_DiscardUnknown() {
	xxx_messageInfo_Video.DiscardUnknown(m)
}

var xxx_messageInfo_Video proto.InternalMessageInfo

func (m *Video) GetVideoId() string {
	if m != nil {
		return m.VideoId
	}
	return ""
}

func (m *Video) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *Video) GetSummary() string {
	if m != nil {
		return m.Summary
	}
	return ""
}

func (m *Video) GetCreatedAt() int64 {
	if m != nil {
		return m.CreatedAt
	}
	return 0
}

func (m *Video) GetPoster() string {
	if m != nil {
		return m.Poster
	}
	return ""
}

func (m *Video) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

type CreateVideoReq struct {
	Title   string `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty"`
	Summary string `protobuf:"bytes,2,opt,name=summary,proto3" json:"summary,omitempty"`
	Poster  string `protobuf:"bytes,3,opt,name=poster,proto3" json:"poster,omitempty"`
	Url     string `protobuf:"bytes,4,opt,name=url,proto3" json:"url,omitempty"`
}

func (m *CreateVideoReq) Reset()         { *m = CreateVideoReq{} }
func (m *CreateVideoReq) String() string { return proto.CompactTextString(m) }
func (*CreateVideoReq) ProtoMessage()    {}
func (*CreateVideoReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_e52170e594c21869, []int{1}
}
func (m *CreateVideoReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateVideoReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateVideoReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateVideoReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateVideoReq.Merge(m, src)
}
func (m *CreateVideoReq) XXX_Size() int {
	return m.Size()
}
func (m *CreateVideoReq) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateVideoReq.DiscardUnknown(m)
}

var xxx_messageInfo_CreateVideoReq proto.InternalMessageInfo

func (m *CreateVideoReq) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *CreateVideoReq) GetSummary() string {
	if m != nil {
		return m.Summary
	}
	return ""
}

func (m *CreateVideoReq) GetPoster() string {
	if m != nil {
		return m.Poster
	}
	return ""
}

func (m *CreateVideoReq) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

type UpdateVideoReq struct {
	VideoId string `protobuf:"bytes,1,opt,name=video_id,json=videoId,proto3" json:"video_id,omitempty"`
	Title   string `protobuf:"bytes,2,opt,name=title,proto3" json:"title,omitempty"`
	Summary string `protobuf:"bytes,3,opt,name=summary,proto3" json:"summary,omitempty"`
	Poster  string `protobuf:"bytes,4,opt,name=poster,proto3" json:"poster,omitempty"`
	Url     string `protobuf:"bytes,5,opt,name=url,proto3" json:"url,omitempty"`
}

func (m *UpdateVideoReq) Reset()         { *m = UpdateVideoReq{} }
func (m *UpdateVideoReq) String() string { return proto.CompactTextString(m) }
func (*UpdateVideoReq) ProtoMessage()    {}
func (*UpdateVideoReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_e52170e594c21869, []int{2}
}
func (m *UpdateVideoReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateVideoReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateVideoReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateVideoReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateVideoReq.Merge(m, src)
}
func (m *UpdateVideoReq) XXX_Size() int {
	return m.Size()
}
func (m *UpdateVideoReq) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateVideoReq.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateVideoReq proto.InternalMessageInfo

func (m *UpdateVideoReq) GetVideoId() string {
	if m != nil {
		return m.VideoId
	}
	return ""
}

func (m *UpdateVideoReq) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *UpdateVideoReq) GetSummary() string {
	if m != nil {
		return m.Summary
	}
	return ""
}

func (m *UpdateVideoReq) GetPoster() string {
	if m != nil {
		return m.Poster
	}
	return ""
}

func (m *UpdateVideoReq) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

type GetVideoListReq struct {
	TypeId   int64 `protobuf:"varint,1,opt,name=type_id,json=typeId,proto3" json:"type_id,omitempty"`
	Page     int64 `protobuf:"varint,2,opt,name=page,proto3" json:"page,omitempty"`
	PageSize int64 `protobuf:"varint,3,opt,name=page_size,json=pageSize,proto3" json:"page_size,omitempty"`
}

func (m *GetVideoListReq) Reset()         { *m = GetVideoListReq{} }
func (m *GetVideoListReq) String() string { return proto.CompactTextString(m) }
func (*GetVideoListReq) ProtoMessage()    {}
func (*GetVideoListReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_e52170e594c21869, []int{3}
}
func (m *GetVideoListReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetVideoListReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetVideoListReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetVideoListReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetVideoListReq.Merge(m, src)
}
func (m *GetVideoListReq) XXX_Size() int {
	return m.Size()
}
func (m *GetVideoListReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GetVideoListReq.DiscardUnknown(m)
}

var xxx_messageInfo_GetVideoListReq proto.InternalMessageInfo

func (m *GetVideoListReq) GetTypeId() int64 {
	if m != nil {
		return m.TypeId
	}
	return 0
}

func (m *GetVideoListReq) GetPage() int64 {
	if m != nil {
		return m.Page
	}
	return 0
}

func (m *GetVideoListReq) GetPageSize() int64 {
	if m != nil {
		return m.PageSize
	}
	return 0
}

type GetVideoListRes struct {
	Videos []*Video `protobuf:"bytes,1,rep,name=videos,proto3" json:"videos,omitempty"`
}

func (m *GetVideoListRes) Reset()         { *m = GetVideoListRes{} }
func (m *GetVideoListRes) String() string { return proto.CompactTextString(m) }
func (*GetVideoListRes) ProtoMessage()    {}
func (*GetVideoListRes) Descriptor() ([]byte, []int) {
	return fileDescriptor_e52170e594c21869, []int{4}
}
func (m *GetVideoListRes) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetVideoListRes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetVideoListRes.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetVideoListRes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetVideoListRes.Merge(m, src)
}
func (m *GetVideoListRes) XXX_Size() int {
	return m.Size()
}
func (m *GetVideoListRes) XXX_DiscardUnknown() {
	xxx_messageInfo_GetVideoListRes.DiscardUnknown(m)
}

var xxx_messageInfo_GetVideoListRes proto.InternalMessageInfo

func (m *GetVideoListRes) GetVideos() []*Video {
	if m != nil {
		return m.Videos
	}
	return nil
}

type UpdateVideoRes struct {
	Ok bool `protobuf:"varint,1,opt,name=ok,proto3" json:"ok,omitempty"`
}

func (m *UpdateVideoRes) Reset()         { *m = UpdateVideoRes{} }
func (m *UpdateVideoRes) String() string { return proto.CompactTextString(m) }
func (*UpdateVideoRes) ProtoMessage()    {}
func (*UpdateVideoRes) Descriptor() ([]byte, []int) {
	return fileDescriptor_e52170e594c21869, []int{5}
}
func (m *UpdateVideoRes) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateVideoRes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateVideoRes.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateVideoRes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateVideoRes.Merge(m, src)
}
func (m *UpdateVideoRes) XXX_Size() int {
	return m.Size()
}
func (m *UpdateVideoRes) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateVideoRes.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateVideoRes proto.InternalMessageInfo

func (m *UpdateVideoRes) GetOk() bool {
	if m != nil {
		return m.Ok
	}
	return false
}

type DeleteVideoReq struct {
	VideoId string `protobuf:"bytes,1,opt,name=video_id,json=videoId,proto3" json:"video_id,omitempty"`
}

func (m *DeleteVideoReq) Reset()         { *m = DeleteVideoReq{} }
func (m *DeleteVideoReq) String() string { return proto.CompactTextString(m) }
func (*DeleteVideoReq) ProtoMessage()    {}
func (*DeleteVideoReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_e52170e594c21869, []int{6}
}
func (m *DeleteVideoReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteVideoReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteVideoReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteVideoReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteVideoReq.Merge(m, src)
}
func (m *DeleteVideoReq) XXX_Size() int {
	return m.Size()
}
func (m *DeleteVideoReq) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteVideoReq.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteVideoReq proto.InternalMessageInfo

func (m *DeleteVideoReq) GetVideoId() string {
	if m != nil {
		return m.VideoId
	}
	return ""
}

type DeleteVideoRes struct {
	Ok bool `protobuf:"varint,1,opt,name=ok,proto3" json:"ok,omitempty"`
}

func (m *DeleteVideoRes) Reset()         { *m = DeleteVideoRes{} }
func (m *DeleteVideoRes) String() string { return proto.CompactTextString(m) }
func (*DeleteVideoRes) ProtoMessage()    {}
func (*DeleteVideoRes) Descriptor() ([]byte, []int) {
	return fileDescriptor_e52170e594c21869, []int{7}
}
func (m *DeleteVideoRes) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteVideoRes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteVideoRes.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteVideoRes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteVideoRes.Merge(m, src)
}
func (m *DeleteVideoRes) XXX_Size() int {
	return m.Size()
}
func (m *DeleteVideoRes) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteVideoRes.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteVideoRes proto.InternalMessageInfo

func (m *DeleteVideoRes) GetOk() bool {
	if m != nil {
		return m.Ok
	}
	return false
}

type GetVideoReq struct {
	VideoId string `protobuf:"bytes,1,opt,name=video_id,json=videoId,proto3" json:"video_id,omitempty"`
}

func (m *GetVideoReq) Reset()         { *m = GetVideoReq{} }
func (m *GetVideoReq) String() string { return proto.CompactTextString(m) }
func (*GetVideoReq) ProtoMessage()    {}
func (*GetVideoReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_e52170e594c21869, []int{8}
}
func (m *GetVideoReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetVideoReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetVideoReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetVideoReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetVideoReq.Merge(m, src)
}
func (m *GetVideoReq) XXX_Size() int {
	return m.Size()
}
func (m *GetVideoReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GetVideoReq.DiscardUnknown(m)
}

var xxx_messageInfo_GetVideoReq proto.InternalMessageInfo

func (m *GetVideoReq) GetVideoId() string {
	if m != nil {
		return m.VideoId
	}
	return ""
}

func init() {
	proto.RegisterType((*Video)(nil), "vsrv.pb.video.Video")
	golang_proto.RegisterType((*Video)(nil), "vsrv.pb.video.Video")
	proto.RegisterType((*CreateVideoReq)(nil), "vsrv.pb.video.CreateVideoReq")
	golang_proto.RegisterType((*CreateVideoReq)(nil), "vsrv.pb.video.CreateVideoReq")
	proto.RegisterType((*UpdateVideoReq)(nil), "vsrv.pb.video.UpdateVideoReq")
	golang_proto.RegisterType((*UpdateVideoReq)(nil), "vsrv.pb.video.UpdateVideoReq")
	proto.RegisterType((*GetVideoListReq)(nil), "vsrv.pb.video.GetVideoListReq")
	golang_proto.RegisterType((*GetVideoListReq)(nil), "vsrv.pb.video.GetVideoListReq")
	proto.RegisterType((*GetVideoListRes)(nil), "vsrv.pb.video.GetVideoListRes")
	golang_proto.RegisterType((*GetVideoListRes)(nil), "vsrv.pb.video.GetVideoListRes")
	proto.RegisterType((*UpdateVideoRes)(nil), "vsrv.pb.video.UpdateVideoRes")
	golang_proto.RegisterType((*UpdateVideoRes)(nil), "vsrv.pb.video.UpdateVideoRes")
	proto.RegisterType((*DeleteVideoReq)(nil), "vsrv.pb.video.DeleteVideoReq")
	golang_proto.RegisterType((*DeleteVideoReq)(nil), "vsrv.pb.video.DeleteVideoReq")
	proto.RegisterType((*DeleteVideoRes)(nil), "vsrv.pb.video.DeleteVideoRes")
	golang_proto.RegisterType((*DeleteVideoRes)(nil), "vsrv.pb.video.DeleteVideoRes")
	proto.RegisterType((*GetVideoReq)(nil), "vsrv.pb.video.GetVideoReq")
	golang_proto.RegisterType((*GetVideoReq)(nil), "vsrv.pb.video.GetVideoReq")
}

func init() { proto.RegisterFile("video_srv.proto", fileDescriptor_e52170e594c21869) }
func init() { golang_proto.RegisterFile("video_srv.proto", fileDescriptor_e52170e594c21869) }

var fileDescriptor_e52170e594c21869 = []byte{
	// 499 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x94, 0xcf, 0x8b, 0xd3, 0x50,
	0x10, 0xc7, 0xfb, 0x92, 0x36, 0x6d, 0xa7, 0x6b, 0x57, 0x86, 0x45, 0x63, 0x64, 0x43, 0x09, 0x1e,
	0x0a, 0x6a, 0x16, 0xd6, 0xab, 0x20, 0xae, 0x82, 0x2c, 0x8a, 0x87, 0x2c, 0x7a, 0xd0, 0x43, 0x69,
	0x9a, 0x67, 0x8d, 0xdb, 0xf2, 0x62, 0xde, 0x6b, 0x61, 0xf7, 0xee, 0xdd, 0xbb, 0xff, 0x8c, 0x47,
	0x8f, 0x3d, 0x7a, 0x94, 0xf6, 0xbf, 0xf0, 0x24, 0x99, 0xa4, 0x24, 0xe9, 0x8f, 0xe0, 0x61, 0x4f,
	0x7d, 0xf3, 0xeb, 0x3b, 0x9f, 0x99, 0x0c, 0x85, 0xc3, 0x79, 0x18, 0x70, 0x31, 0x90, 0xf1, 0xdc,
	0x8d, 0x62, 0xa1, 0x04, 0xde, 0x9a, 0xd3, 0xdb, 0x77, 0x29, 0x60, 0x3d, 0x1e, 0x87, 0xea, 0xf3,
	0xcc, 0x77, 0x47, 0x62, 0x7a, 0x32, 0x16, 0x63, 0x71, 0x42, 0x59, 0xfe, 0xec, 0x13, 0x59, 0x64,
	0xd0, 0x2b, 0xad, 0x76, 0x7e, 0x30, 0x68, 0xbc, 0x4f, 0x0a, 0xf1, 0x1e, 0xb4, 0x52, 0xe9, 0x30,
	0x30, 0x59, 0x8f, 0xf5, 0xdb, 0x5e, 0x93, 0xec, 0xf3, 0x00, 0x8f, 0xa0, 0xa1, 0x42, 0x35, 0xe1,
	0xa6, 0x46, 0xfe, 0xd4, 0x40, 0x13, 0x9a, 0x72, 0x36, 0x9d, 0x0e, 0xe3, 0x2b, 0x53, 0x4f, 0xf3,
	0x33, 0x13, 0x8f, 0x01, 0x46, 0x31, 0x1f, 0x2a, 0x1e, 0x0c, 0x86, 0xca, 0xac, 0xf7, 0x58, 0x5f,
	0xf7, 0xda, 0x99, 0xe7, 0xb9, 0xc2, 0x3b, 0x60, 0x44, 0x42, 0x2a, 0x1e, 0x9b, 0x0d, 0xaa, 0xcb,
	0x2c, 0xbc, 0x0d, 0xfa, 0x2c, 0x9e, 0x98, 0x06, 0x39, 0x93, 0xa7, 0xf3, 0x05, 0xba, 0x2f, 0xa8,
	0x8c, 0x10, 0x3d, 0xfe, 0x35, 0x47, 0x61, 0x7b, 0x50, 0xb4, 0x32, 0x4a, 0xde, 0x4b, 0xdf, 0xd5,
	0xab, 0x9e, 0xf7, 0xfa, 0xc6, 0xa0, 0xfb, 0x2e, 0x0a, 0x8a, 0xcd, 0x6e, 0x70, 0x25, 0x39, 0x47,
	0x7d, 0x17, 0x47, 0x23, 0xe7, 0xf8, 0x08, 0x87, 0xaf, 0xb8, 0x22, 0x86, 0x37, 0xa1, 0x54, 0x09,
	0xc7, 0x5d, 0x68, 0xaa, 0xab, 0x88, 0xaf, 0x31, 0x74, 0xcf, 0x48, 0xcc, 0xf3, 0x00, 0x11, 0xea,
	0xd1, 0x70, 0x9c, 0x42, 0xe8, 0x1e, 0xbd, 0xf1, 0x3e, 0xb4, 0x93, 0xdf, 0x81, 0x0c, 0xaf, 0x39,
	0x51, 0xe8, 0x5e, 0x2b, 0x71, 0x5c, 0x84, 0xd7, 0xdc, 0x79, 0xb6, 0x29, 0x2e, 0xf1, 0x11, 0x18,
	0x34, 0x94, 0x34, 0x59, 0x4f, 0xef, 0x77, 0x4e, 0x8f, 0xdc, 0xd2, 0x41, 0xb9, 0xe9, 0x36, 0xb2,
	0x1c, 0xa7, 0xb7, 0xb1, 0x24, 0x89, 0x5d, 0xd0, 0xc4, 0x25, 0x71, 0xb5, 0x3c, 0x4d, 0x5c, 0x3a,
	0x0f, 0xa1, 0xfb, 0x92, 0x4f, 0xf8, 0x7f, 0xad, 0x31, 0x91, 0x2b, 0x25, 0x6f, 0xcb, 0xf5, 0xa1,
	0xb3, 0x26, 0xae, 0xd6, 0x3a, 0xfd, 0xab, 0xc1, 0x01, 0xe5, 0x5d, 0xf0, 0x78, 0x1e, 0x8e, 0x38,
	0x9e, 0x41, 0xa7, 0x70, 0x3d, 0x78, 0xbc, 0x31, 0x58, 0xf9, 0xb2, 0xac, 0x9d, 0x73, 0xe3, 0x53,
	0x68, 0xad, 0xdb, 0xa3, 0xb5, 0x91, 0x51, 0xe0, 0xda, 0x53, 0xfd, 0x16, 0x0e, 0x8a, 0xeb, 0x46,
	0x7b, 0x8f, 0x42, 0xf6, 0xa1, 0xad, 0xea, 0xb8, 0xc4, 0xd7, 0xd0, 0x29, 0x6c, 0x7f, 0x6b, 0xa2,
	0xf2, 0xf9, 0x5a, 0x95, 0x61, 0x12, 0x2b, 0xec, 0x7e, 0x4b, 0xac, 0xfc, 0x11, 0xad, 0xca, 0xb0,
	0x3c, 0x7b, 0xf0, 0x6b, 0x69, 0xb3, 0xc5, 0xd2, 0x66, 0x7f, 0x96, 0x36, 0xfb, 0xbe, 0xb2, 0x6b,
	0x3f, 0x57, 0x36, 0x5b, 0xac, 0xec, 0xda, 0xef, 0x95, 0x5d, 0xfb, 0x60, 0x24, 0xb5, 0x91, 0xef,
	0x1b, 0xf4, 0xa7, 0xf3, 0xe4, 0x5f, 0x00, 0x00, 0x00, 0xff, 0xff, 0xb4, 0xd8, 0xa3, 0x6a, 0xc5,
	0x04, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// VideoServiceClient is the client API for VideoService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type VideoServiceClient interface {
	CreateVideo(ctx context.Context, in *CreateVideoReq, opts ...grpc.CallOption) (*Video, error)
	GetVideo(ctx context.Context, in *GetVideoReq, opts ...grpc.CallOption) (*Video, error)
	GetVideoList(ctx context.Context, in *GetVideoListReq, opts ...grpc.CallOption) (*GetVideoListRes, error)
	UpdateVideo(ctx context.Context, in *UpdateVideoReq, opts ...grpc.CallOption) (*UpdateVideoRes, error)
	DeleteVideo(ctx context.Context, in *DeleteVideoReq, opts ...grpc.CallOption) (*DeleteVideoRes, error)
}

type videoServiceClient struct {
	cc *grpc.ClientConn
}

func NewVideoServiceClient(cc *grpc.ClientConn) VideoServiceClient {
	return &videoServiceClient{cc}
}

func (c *videoServiceClient) CreateVideo(ctx context.Context, in *CreateVideoReq, opts ...grpc.CallOption) (*Video, error) {
	out := new(Video)
	err := c.cc.Invoke(ctx, "/vsrv.pb.video.VideoService/CreateVideo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *videoServiceClient) GetVideo(ctx context.Context, in *GetVideoReq, opts ...grpc.CallOption) (*Video, error) {
	out := new(Video)
	err := c.cc.Invoke(ctx, "/vsrv.pb.video.VideoService/GetVideo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *videoServiceClient) GetVideoList(ctx context.Context, in *GetVideoListReq, opts ...grpc.CallOption) (*GetVideoListRes, error) {
	out := new(GetVideoListRes)
	err := c.cc.Invoke(ctx, "/vsrv.pb.video.VideoService/GetVideoList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *videoServiceClient) UpdateVideo(ctx context.Context, in *UpdateVideoReq, opts ...grpc.CallOption) (*UpdateVideoRes, error) {
	out := new(UpdateVideoRes)
	err := c.cc.Invoke(ctx, "/vsrv.pb.video.VideoService/UpdateVideo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *videoServiceClient) DeleteVideo(ctx context.Context, in *DeleteVideoReq, opts ...grpc.CallOption) (*DeleteVideoRes, error) {
	out := new(DeleteVideoRes)
	err := c.cc.Invoke(ctx, "/vsrv.pb.video.VideoService/DeleteVideo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// VideoServiceServer is the server API for VideoService service.
type VideoServiceServer interface {
	CreateVideo(context.Context, *CreateVideoReq) (*Video, error)
	GetVideo(context.Context, *GetVideoReq) (*Video, error)
	GetVideoList(context.Context, *GetVideoListReq) (*GetVideoListRes, error)
	UpdateVideo(context.Context, *UpdateVideoReq) (*UpdateVideoRes, error)
	DeleteVideo(context.Context, *DeleteVideoReq) (*DeleteVideoRes, error)
}

// UnimplementedVideoServiceServer can be embedded to have forward compatible implementations.
type UnimplementedVideoServiceServer struct {
}

func (*UnimplementedVideoServiceServer) CreateVideo(ctx context.Context, req *CreateVideoReq) (*Video, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateVideo not implemented")
}
func (*UnimplementedVideoServiceServer) GetVideo(ctx context.Context, req *GetVideoReq) (*Video, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetVideo not implemented")
}
func (*UnimplementedVideoServiceServer) GetVideoList(ctx context.Context, req *GetVideoListReq) (*GetVideoListRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetVideoList not implemented")
}
func (*UnimplementedVideoServiceServer) UpdateVideo(ctx context.Context, req *UpdateVideoReq) (*UpdateVideoRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateVideo not implemented")
}
func (*UnimplementedVideoServiceServer) DeleteVideo(ctx context.Context, req *DeleteVideoReq) (*DeleteVideoRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteVideo not implemented")
}

func RegisterVideoServiceServer(s *grpc.Server, srv VideoServiceServer) {
	s.RegisterService(&_VideoService_serviceDesc, srv)
}

func _VideoService_CreateVideo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateVideoReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VideoServiceServer).CreateVideo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vsrv.pb.video.VideoService/CreateVideo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VideoServiceServer).CreateVideo(ctx, req.(*CreateVideoReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _VideoService_GetVideo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetVideoReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VideoServiceServer).GetVideo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vsrv.pb.video.VideoService/GetVideo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VideoServiceServer).GetVideo(ctx, req.(*GetVideoReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _VideoService_GetVideoList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetVideoListReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VideoServiceServer).GetVideoList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vsrv.pb.video.VideoService/GetVideoList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VideoServiceServer).GetVideoList(ctx, req.(*GetVideoListReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _VideoService_UpdateVideo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateVideoReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VideoServiceServer).UpdateVideo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vsrv.pb.video.VideoService/UpdateVideo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VideoServiceServer).UpdateVideo(ctx, req.(*UpdateVideoReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _VideoService_DeleteVideo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteVideoReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VideoServiceServer).DeleteVideo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vsrv.pb.video.VideoService/DeleteVideo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VideoServiceServer).DeleteVideo(ctx, req.(*DeleteVideoReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _VideoService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "vsrv.pb.video.VideoService",
	HandlerType: (*VideoServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateVideo",
			Handler:    _VideoService_CreateVideo_Handler,
		},
		{
			MethodName: "GetVideo",
			Handler:    _VideoService_GetVideo_Handler,
		},
		{
			MethodName: "GetVideoList",
			Handler:    _VideoService_GetVideoList_Handler,
		},
		{
			MethodName: "UpdateVideo",
			Handler:    _VideoService_UpdateVideo_Handler,
		},
		{
			MethodName: "DeleteVideo",
			Handler:    _VideoService_DeleteVideo_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "video_srv.proto",
}

func (m *Video) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Video) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.VideoId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintVideoSrv(dAtA, i, uint64(len(m.VideoId)))
		i += copy(dAtA[i:], m.VideoId)
	}
	if len(m.Title) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintVideoSrv(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	if len(m.Summary) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintVideoSrv(dAtA, i, uint64(len(m.Summary)))
		i += copy(dAtA[i:], m.Summary)
	}
	if m.CreatedAt != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintVideoSrv(dAtA, i, uint64(m.CreatedAt))
	}
	if len(m.Poster) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintVideoSrv(dAtA, i, uint64(len(m.Poster)))
		i += copy(dAtA[i:], m.Poster)
	}
	if len(m.Url) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintVideoSrv(dAtA, i, uint64(len(m.Url)))
		i += copy(dAtA[i:], m.Url)
	}
	return i, nil
}

func (m *CreateVideoReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateVideoReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Title) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintVideoSrv(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	if len(m.Summary) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintVideoSrv(dAtA, i, uint64(len(m.Summary)))
		i += copy(dAtA[i:], m.Summary)
	}
	if len(m.Poster) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintVideoSrv(dAtA, i, uint64(len(m.Poster)))
		i += copy(dAtA[i:], m.Poster)
	}
	if len(m.Url) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintVideoSrv(dAtA, i, uint64(len(m.Url)))
		i += copy(dAtA[i:], m.Url)
	}
	return i, nil
}

func (m *UpdateVideoReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateVideoReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.VideoId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintVideoSrv(dAtA, i, uint64(len(m.VideoId)))
		i += copy(dAtA[i:], m.VideoId)
	}
	if len(m.Title) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintVideoSrv(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	if len(m.Summary) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintVideoSrv(dAtA, i, uint64(len(m.Summary)))
		i += copy(dAtA[i:], m.Summary)
	}
	if len(m.Poster) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintVideoSrv(dAtA, i, uint64(len(m.Poster)))
		i += copy(dAtA[i:], m.Poster)
	}
	if len(m.Url) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintVideoSrv(dAtA, i, uint64(len(m.Url)))
		i += copy(dAtA[i:], m.Url)
	}
	return i, nil
}

func (m *GetVideoListReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetVideoListReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TypeId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintVideoSrv(dAtA, i, uint64(m.TypeId))
	}
	if m.Page != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintVideoSrv(dAtA, i, uint64(m.Page))
	}
	if m.PageSize != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintVideoSrv(dAtA, i, uint64(m.PageSize))
	}
	return i, nil
}

func (m *GetVideoListRes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetVideoListRes) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Videos) > 0 {
		for _, msg := range m.Videos {
			dAtA[i] = 0xa
			i++
			i = encodeVarintVideoSrv(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *UpdateVideoRes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateVideoRes) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ok {
		dAtA[i] = 0x8
		i++
		if m.Ok {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *DeleteVideoReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteVideoReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.VideoId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintVideoSrv(dAtA, i, uint64(len(m.VideoId)))
		i += copy(dAtA[i:], m.VideoId)
	}
	return i, nil
}

func (m *DeleteVideoRes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteVideoRes) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ok {
		dAtA[i] = 0x8
		i++
		if m.Ok {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *GetVideoReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetVideoReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.VideoId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintVideoSrv(dAtA, i, uint64(len(m.VideoId)))
		i += copy(dAtA[i:], m.VideoId)
	}
	return i, nil
}

func encodeVarintVideoSrv(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Video) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.VideoId)
	if l > 0 {
		n += 1 + l + sovVideoSrv(uint64(l))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovVideoSrv(uint64(l))
	}
	l = len(m.Summary)
	if l > 0 {
		n += 1 + l + sovVideoSrv(uint64(l))
	}
	if m.CreatedAt != 0 {
		n += 1 + sovVideoSrv(uint64(m.CreatedAt))
	}
	l = len(m.Poster)
	if l > 0 {
		n += 1 + l + sovVideoSrv(uint64(l))
	}
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovVideoSrv(uint64(l))
	}
	return n
}

func (m *CreateVideoReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovVideoSrv(uint64(l))
	}
	l = len(m.Summary)
	if l > 0 {
		n += 1 + l + sovVideoSrv(uint64(l))
	}
	l = len(m.Poster)
	if l > 0 {
		n += 1 + l + sovVideoSrv(uint64(l))
	}
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovVideoSrv(uint64(l))
	}
	return n
}

func (m *UpdateVideoReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.VideoId)
	if l > 0 {
		n += 1 + l + sovVideoSrv(uint64(l))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovVideoSrv(uint64(l))
	}
	l = len(m.Summary)
	if l > 0 {
		n += 1 + l + sovVideoSrv(uint64(l))
	}
	l = len(m.Poster)
	if l > 0 {
		n += 1 + l + sovVideoSrv(uint64(l))
	}
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovVideoSrv(uint64(l))
	}
	return n
}

func (m *GetVideoListReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TypeId != 0 {
		n += 1 + sovVideoSrv(uint64(m.TypeId))
	}
	if m.Page != 0 {
		n += 1 + sovVideoSrv(uint64(m.Page))
	}
	if m.PageSize != 0 {
		n += 1 + sovVideoSrv(uint64(m.PageSize))
	}
	return n
}

func (m *GetVideoListRes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Videos) > 0 {
		for _, e := range m.Videos {
			l = e.Size()
			n += 1 + l + sovVideoSrv(uint64(l))
		}
	}
	return n
}

func (m *UpdateVideoRes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ok {
		n += 2
	}
	return n
}

func (m *DeleteVideoReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.VideoId)
	if l > 0 {
		n += 1 + l + sovVideoSrv(uint64(l))
	}
	return n
}

func (m *DeleteVideoRes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ok {
		n += 2
	}
	return n
}

func (m *GetVideoReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.VideoId)
	if l > 0 {
		n += 1 + l + sovVideoSrv(uint64(l))
	}
	return n
}

func sovVideoSrv(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozVideoSrv(x uint64) (n int) {
	return sovVideoSrv(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Video) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVideoSrv
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Video: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Video: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VideoId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVideoSrv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVideoSrv
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVideoSrv
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VideoId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVideoSrv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVideoSrv
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVideoSrv
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Summary", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVideoSrv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVideoSrv
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVideoSrv
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Summary = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			m.CreatedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVideoSrv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreatedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Poster", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVideoSrv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVideoSrv
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVideoSrv
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Poster = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVideoSrv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVideoSrv
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVideoSrv
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVideoSrv(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVideoSrv
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVideoSrv
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateVideoReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVideoSrv
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateVideoReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateVideoReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVideoSrv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVideoSrv
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVideoSrv
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Summary", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVideoSrv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVideoSrv
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVideoSrv
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Summary = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Poster", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVideoSrv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVideoSrv
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVideoSrv
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Poster = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVideoSrv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVideoSrv
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVideoSrv
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVideoSrv(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVideoSrv
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVideoSrv
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateVideoReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVideoSrv
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateVideoReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateVideoReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VideoId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVideoSrv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVideoSrv
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVideoSrv
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VideoId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVideoSrv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVideoSrv
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVideoSrv
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Summary", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVideoSrv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVideoSrv
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVideoSrv
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Summary = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Poster", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVideoSrv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVideoSrv
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVideoSrv
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Poster = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVideoSrv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVideoSrv
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVideoSrv
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVideoSrv(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVideoSrv
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVideoSrv
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetVideoListReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVideoSrv
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetVideoListReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetVideoListReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeId", wireType)
			}
			m.TypeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVideoSrv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TypeId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Page", wireType)
			}
			m.Page = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVideoSrv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Page |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageSize", wireType)
			}
			m.PageSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVideoSrv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PageSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipVideoSrv(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVideoSrv
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVideoSrv
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetVideoListRes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVideoSrv
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetVideoListRes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetVideoListRes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Videos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVideoSrv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVideoSrv
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVideoSrv
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Videos = append(m.Videos, &Video{})
			if err := m.Videos[len(m.Videos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVideoSrv(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVideoSrv
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVideoSrv
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateVideoRes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVideoSrv
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateVideoRes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateVideoRes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ok", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVideoSrv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ok = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipVideoSrv(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVideoSrv
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVideoSrv
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteVideoReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVideoSrv
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteVideoReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteVideoReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VideoId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVideoSrv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVideoSrv
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVideoSrv
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VideoId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVideoSrv(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVideoSrv
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVideoSrv
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteVideoRes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVideoSrv
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteVideoRes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteVideoRes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ok", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVideoSrv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ok = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipVideoSrv(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVideoSrv
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVideoSrv
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetVideoReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVideoSrv
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetVideoReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetVideoReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VideoId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVideoSrv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVideoSrv
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVideoSrv
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VideoId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVideoSrv(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVideoSrv
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVideoSrv
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipVideoSrv(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowVideoSrv
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowVideoSrv
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowVideoSrv
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthVideoSrv
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthVideoSrv
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowVideoSrv
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipVideoSrv(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthVideoSrv
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthVideoSrv = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowVideoSrv   = fmt.Errorf("proto: integer overflow")
)
